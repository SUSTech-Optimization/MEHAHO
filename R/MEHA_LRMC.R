#' Solving low rank matrix completion hyper-parameter selection problem based on MEHA
#' @description This R function is written to solve the hyper-parameter selection problem of low-rank matrix completion using the MEHA,
#'     please refer to the listed literature for the specific algorithm and model.
#' @references Liu, R., Liu, Z., Yao, W., Zeng, S., & Zhang, J. (2024).
#'     "Rethinking Moreau Envelope for Nonconvex Bi-Level Optimization: A Single-loop and Hessian-free Solution Strategy."
#'     Available at: https://openreview.net/forum?id=i6EtCiIK4a
#'
#'     Gao, L., Ye, J. J., Yin, H., Zeng, S., & Zhang, J. (2022).
#'     "Value function based difference-of-convex algorithm for bilevel hyperparameter selection problems."
#'     Available at: https://proceedings.mlr.press/v162/gao22j.html
#' @param M_val Input matrix for validation with dimensions n by p,
#'     with matrix elements equal to 0 at positions other than the validation entries.
#' @param M_tr Input matrix for training with dimensions n by p,
#'     with matrix elements equal to 0 at positions other than the training entries.
#' @param M_val_index Index of validation entries dimensions n by p,
#'     which is a binary matrix where the positions of elements equal to 1
#'     represent the coordinates of the validation entries in the matrix.
#' @param M_tr_index Index of training entries dimensions n by p,
#'     which is a binary matrix where the positions of elements equal to 1 represent the coordinates of the training entries in the matrix.
#' @param A Row feature matrix of n by p.
#' @param B Column feature matrix of n by p.
#' @param group A vector to describe the feature group information,
#'     with each
#'     element representing the specific number of features in each group.
#'     For example, if the coefficients of dimension 12 are divided into 3 groups which is 6, 3, and 3 dimensions,
#'     then \code{group=(6,3,3)}. In the case of non-sequential grouping,
#'         the permutation matrix can be converted to sequential grouping.
#' @param N Total iterations. Default is 200.
#' @param alpha Proximal gradient stepsize of \code{x}. Default is 1e-4.
#' @param beta Proximal gradient stepsize of \code{a} and \code{b}. Default is 1e-4.
#' @param eta Proximal gradient stepsize of the proxima \code{theta}. Default is 1e-4.
#' @param gamma Moreau envelope parameter. Default is 10.
#' @param c \eqn{\underline{c}} in MEHA,
#'     which is used to generate the penalty parameter \eqn{c_k} in LV-HBA by \eqn{c_k = \underline{c}(k+1)^power}.
#'     Default is 2.
#' @param power The power exponent in \eqn{c_k = \underline{c}(k+1)^{power}}. Default is 0.48.
#' @param tol Tolerance. IF \eqn{|(x^{k + 1}, y^{k + 1}) - (x^{k}, y^k)|/\sqrt{1+|(x^{k}, y^k)|^2} < tol},
#'     then terminate the iteration, where \eqn{x^k} represents the upper-level variable, \eqn{y^k} represents the lower-level variable.
#'     Default is 0.05.
#' @param auto_tuning When alpha, beta,
#'     eta are fixed, whether an auto-hyperparameter-tuning is needed.
#'     Default is \code{FALSE}.
#' @param temperature Temperature of simulating annealing method for auto-hyperparameter-tuning.
#'     Default is 0.1.
#'
#' @return
#'
#'   \item{x}{A vector of length (2M+1), where M denotes the total group number.
#'       The first M values are the within-group penalty strengths of row feature
#'       coefficients \code{a}, the second M values are within-group penalty strength
#'       of column feature coefficients \code{b}, the last value is the penalty
#'       strengths of low rank effect matrix \code{Q}.}
#'   \item{a}{Row feature coefficient.}
#'   \item{b}{Column feature coefficient.}
#'   \item{Q}{low rank effect matrix.}
#'   \item{X_seq}{A list. Describe the sequence x generated by MEHA in the iterative process.}
#'   \item{a_seq}{A list. Describe the sequence a generated by MEHA in the iterative process.}
#'   \item{b_seq}{A list. Describe the sequence b generated by MEHA in the iterative process.}
#'   \item{Q_seq}{A list. Describe the sequence Q generated by MEHA in the iterative process.}
#'   \item{F_seq}{The upper function value sequence generated in the iterative process based on validation set.}
#'
#' @export



MEHA_LRMC = function(M_val, M_tr, M_val_index, M_tr_index,
                     A, B, group, N = 200, alpha = 1e-4, beta = 1e-4, eta = 1e-4,
                     gamma = 10, c = 2, power = 0.48, tol = 0.05, auto_tuning = FALSE,
                     temperature = 0.1){

  library(progress)
  library(truncnorm)

  main_fun <- function(M_val, M_tr, M_val_index, M_tr_index, A, B, group, N, alpha, beta, eta, gamma, c, power, tol){

    G_num = dim(group)[1] # The total number of groups
    n = dim(M_val_index)[1]
    p = dim(A)[2] # Dimension of features
    if (p != sum(group)) {
      stop("Error: p != sum(group), the grouping condition contradicts the number of features")
    }

    ones_n = matrix(rep(1), nrow = n)
    ones_nn = matrix(rep(1), nrow = n, ncol = n)
    zeros_2g1 = matrix(rep(0), nrow = 2*G_num + 1)
    zeros_g = matrix(rep(0), nrow = G_num)
    zeros_p = matrix(rep(0), nrow = p)

    # Initial values
    a =  0*matrix(rep(1), nrow = p)
    b =  0*matrix(rep(1), nrow = p)
    Q =  0*matrix(rep(1), nrow = n, ncol = n)
    x =  matrix(rep(0.1), nrow = 2*G_num + 1)
    x[2*G_num + 1] =  1
    theta_a = a
    theta_b = b
    theta_Q = Q


    # Upper objective function
    up_fun = function(x, a, b, Q){
      result = 0.5*norm((M_val - A %*% a %*% t(ones_n) - t(B %*% b %*% t(ones_n)) - Q) * M_val_index, type = "F")^2
      return(result)
    }

    # low_fun = function(x, a, b, Q){
    #   result = 0.5*norm((M_tr - A %*% a %*% t(ones_n) - t(B %*% b %*% t(ones_n)) - Q) * M_tr_index, type = "F")^2
    #   return(result)
    # }


    # Gradient update function for x and y (i.e. a, b and Q)
    F_x = function(x, a, b, Q){
      result = zeros_2g1
      return(result)
    }

    F_a = function(x, a, b, Q){
      result = zeros_p
      for (i in 1:nrow(M_val_index)) {
        for (j in 1:ncol(M_val_index)) {
          if (M_val_index[i, j] == 1) {
            result = result + as.numeric((M_val[i, j] - A[i, ] %*% a - B[j, ] %*% b - Q[i,j] ))*(-1*A[i, ])
          }
        }
      }
      return(result)
    }

    F_b = function(x, a, b, Q){
      result = zeros_p
      for (i in 1:nrow(M_val_index)) {
        for (j in 1:ncol(M_val_index)) {
          if (M_val_index[i, j] == 1) {
            result = result + as.numeric((M_val[i, j] - A[i, ] %*% a - B[j, ] %*% b - Q[i,j] ))*(-1*B[j, ])
          }
        }
      }
      return(result)
    }

    F_Q = function(x, a, b, Q){
      result = 0*ones_nn
      for (i in 1:nrow(M_val_index)) {
        for (j in 1:ncol(M_val_index)) {
          if (M_val_index[i, j] == 1) {
            result[i,j] = as.numeric((M_val[i, j] - A[i, ] %*% a - B[j, ] %*% b - Q[i,j] ))*(-1)
          }
        }
      }
      return(result)
    }



    f_x = function(x, a, b, Q){
      result = zeros_2g1
      return(result)
    }


    f_a = function(x, a, b, Q){
      result = zeros_p
      for (i in 1:nrow(M_tr_index)) {
        for (j in 1:ncol(M_tr_index)) {
          if (M_tr_index[i, j] == 1) {
            result = result + as.numeric((M_tr[i, j] - A[i, ] %*% a - B[j, ] %*% b - Q[i,j] ))*(-1*A[i, ])
          }
        }
      }
      return(result)
    }

    f_b = function(x, a, b, Q){
      result = zeros_p
      for (i in 1:nrow(M_tr_index)) {
        for (j in 1:ncol(M_tr_index)) {
          if (M_tr_index[i, j] == 1) {
            result = result + as.numeric((M_tr[i, j] - A[i, ] %*% a - B[j, ] %*% b - Q[i,j] ))*(-1*B[j, ])
          }
        }
      }
      return(result)
    }

    f_Q = function(x, a, b, Q){
      result = 0*ones_nn
      for (i in 1:nrow(M_tr_index)) {
        for (j in 1:ncol(M_tr_index)) {
          if (M_tr_index[i, j] == 1) {
            result[i,j] = as.numeric((M_tr[i, j] - A[i, ] %*% a - B[j, ] %*% b - Q[i,j] ))*(-1)
          }
        }
      }
      return(result)
    }


    g_x = function(x, a, b, Q){
      resulta = zeros_g
      resultb = zeros_g
      for (k in 1:G_num) {
        ak = a[(sum(group[1:k]) - group[k] + 1):sum(group[1:k])]
        resulta[k] = norm( ak ,type = "2")
      }
      for (k in 1:G_num) {
        bk = b[(sum(group[1:k]) - group[k] + 1):sum(group[1:k])]
        resultb[k] = norm( bk ,type = "2")
      }
      svd_Q = svd(Q)
      resultQ = sum(svd_Q$d)
      return(rbind(resulta, resultb, resultQ))
    }


    # Proximal operators for theta
    prox_eta_a = function(x, a, b, Q, theta_a, theta_b, theta_Q){
      z_a = theta_a - eta * (f_a(x, theta_a, theta_b, theta_Q) + (theta_a - a) / gamma)
      result = zeros_p
      for (k in 1:G_num) {
        z_ak = z_a[(sum(group[1:k]) - group[k] + 1):sum(group[1:k])]
        if (eta * x[k] > 0) {
          result[(sum(group[1:k]) - group[k] + 1):sum(group[1:k])] = (1 - eta * x[k]/(max(norm(z_ak,type = "2"), eta * x[k])))*z_ak
        } else {
          result[(sum(group[1:k]) - group[k] + 1):sum(group[1:k])] = z_ak
        }
      }
      return(result)
    }

    prox_eta_b = function(x, a, b, Q, theta_a, theta_b, theta_Q){
      z_b = theta_b - eta * (f_b(x, theta_a, theta_b, theta_Q) + (theta_b - b) / gamma)
      result = zeros_p
      for (k in 1:G_num) {
        z_bk = z_b[(sum(group[1:k]) - group[k] + 1):sum(group[1:k])]
        if (eta * x[k + G_num] > 0) {
          result[(sum(group[1:k]) - group[k] + 1):sum(group[1:k])] = (1 - eta * x[k + G_num]/(max(norm(z_bk,type = "2"), eta * x[k + G_num])))*z_bk
        } else {
          result[(sum(group[1:k]) - group[k] + 1):sum(group[1:k])] = z_bk
        }
      }
      return(result)
    }

    prox_eta_Q = function(x, a, b, Q, theta_a, theta_b, theta_Q){
      z_Q = theta_Q - eta * (f_Q(x, theta_a, theta_b, theta_Q) + (theta_Q - Q) / gamma)
      result = ones_nn
      svd_result = svd(z_Q)
      if (eta * x[2*G_num + 1] > 0) {
        D = pmax(svd_result$d - eta * x[2*G_num + 1], 0)
        result = svd_result$u %*% diag(D) %*% t(svd_result$v)
      } else {
        result = z_Q
      }
      return(result)
    }


    # Proximal operators for y
    prox_beta_a = function(x, a, b, Q, dka, dkb, dkQ){
      z_a = a - beta * dka
      result = zeros_p
      for (k in 1:G_num) {
        z_ak = z_a[(sum(group[1:k]) - group[k] + 1):sum(group[1:k])]
        if (beta * x[k] > 0) {
          result[(sum(group[1:k]) - group[k] + 1):sum(group[1:k])] = (1 - beta * x[k]/(max(norm(z_ak,type = "2"), beta * x[k])))*z_ak
        } else {
          result[(sum(group[1:k]) - group[k] + 1):sum(group[1:k])] = z_ak
        }
      }
      return(result)
    }


    prox_beta_b = function(x, a, b, Q, dka, dkb, dkQ){
      z_b = b - beta * dkb
      result = zeros_p
      for (k in 1:G_num){
        z_bk = z_b[(sum(group[1:k]) - group[k] + 1):sum(group[1:k])]
        if (beta * x[k + G_num] > 0) {
          result[(sum(group[1:k]) - group[k] + 1):sum(group[1:k])] = (1 - beta * x[k + G_num]/(max(norm(z_bk,type = "2"), beta * x[k + G_num])))*z_bk
        } else {
          result[(sum(group[1:k]) - group[k] + 1):sum(group[1:k])] = z_bk
        }
      }
      return(result)
    }

    prox_beta_Q = function(x, a, b, Q, dka, dkb, dkQ){
      z_Q = Q - beta * dkQ
      result = ones_nn
      svd_result = svd(z_Q)
      if (beta * x[2*G_num + 1] > 0) {
        D = pmax(svd_result$d - beta * x[2*G_num + 1], 0)
        result = svd_result$u %*% diag(D) %*% t(svd_result$v)
      } else {
        result = z_Q
      }

      return(result)
    }


    # Store the results
    X_seq = list()
    Y_a_seq = list()
    Y_b_seq = list()
    Y_Q_seq = list()
    Theta_a_seq = list()
    Theta_b_seq = list()
    Theta_Q_seq = list()
    F_seq = numeric(N)

    # Iteration
    for (k in 1:N) {
      xk = x
      ak = a
      bk = b
      Qk = Q
      theta_ak = theta_a
      theta_bk = theta_b
      theta_Qk = theta_Q

      ck = c*(k)^power
      theta_a = prox_eta_a(x, a, b, Q, theta_a, theta_b, theta_Q)
      theta_b = prox_eta_b(x, a, b, Q, theta_a, theta_b, theta_Q)
      theta_Q = prox_eta_Q(x, a, b, Q, theta_a, theta_b, theta_Q)

      dkx = (1/ck) * F_x(x, a, b, Q) + f_x(x, a, b, Q) + g_x(x, a, b, Q) - f_x(x, theta_a, theta_b, theta_Q) - g_x(x, theta_a, theta_b, theta_Q)

      x = pmax(x - alpha * dkx, zeros_2g1)

      dka = (1/ck) * F_a(x, a, b, Q) + f_a(x, a, b, Q) - (a - theta_a)/gamma
      dkb = (1/ck) * F_b(x, a, b, Q) + f_b(x, a, b, Q) - (b - theta_b)/gamma
      dkQ = (1/ck) * F_Q(x, a, b, Q) + f_Q(x, a, b, Q) - (Q - theta_Q)/gamma


      a = prox_beta_a(x, a, b, Q, dka, dkb, dkQ)
      b = prox_beta_b(x, a, b, Q, dka, dkb, dkQ)
      Q = prox_beta_Q(x, a, b, Q, dka, dkb, dkQ)


      X_seq[[k]] = x
      Y_a_seq[[k]] = a
      Y_b_seq[[k]] = b
      Y_Q_seq[[k]] = Q
      Theta_a_seq[[k]] = theta_a
      Theta_b_seq[[k]] = theta_b
      Theta_Q_seq[[k]] = theta_Q
      F_seq[k] = up_fun(x, a, b, Q)

      # conv_criterion =
      #   sqrt( norm(x - xk , "2")^2 +
      #           norm(a - ak, "2")^2 + norm(b - bk, "2")^2 + norm(Q - Qk, "F")^2 +
      #           norm(theta_a - theta_ak, "2")^2 + norm(theta_b - theta_bk, "2")^2 + norm(theta_Q - theta_Qk, "F")^2 )
      # / sqrt( 1 + norm(xk , "2")^2 +
      #           norm(ak, "2")^2 + norm(bk, "2")^2 + norm(Qk, "F")^2 +
      #           norm(theta_ak, "2")^2 + norm(theta_bk, "2")^2 + norm(theta_Qk, "F")^2 )
      conv_criterion =
        sqrt( norm(x - xk , "2")^2 + norm(a - ak, "2")^2 + norm(b - bk, "2")^2 + norm(Q - Qk, "F")^2 ) / sqrt( 1 + norm(xk , "2")^2 + norm(ak, "2")^2 + norm(bk, "2")^2 + norm(Qk, "F")^2)


      if (!is.na(conv_criterion) && conv_criterion < tol) {
        if(auto_tuning == FALSE){
          cat("Terminating at iteration", k, "\n")
        }
        F_seq = F_seq[1:k]
        break
      }
    }

    # return(list(x = x, a = a, b = b, Q = Q, theta_a = theta_a, theta_B = theta_b, theta_Q = theta_Q,
    #             X_seq = X_seq, Y_a_seq = Y_a_seq, Y_b_seq = Y_b_seq, Y_Q_seq = Y_Q_seq, Theta_seq= Theta_seq,
    #             Theta_a_seq = Theta_a_seq, Theta_b_seq = Theta_b_seq, Theta_Q_seq = Theta_Q_seq,
    #             F_seq = F_seq))
    return(list(x = x, a = a, b = b, Q = Q, X_seq = X_seq, a_seq = Y_a_seq, b_seq = Y_b_seq, Q_seq = Y_Q_seq, F_seq = F_seq))

  }

  if(auto_tuning == TRUE){
    message("\n","Auto-hyperparameters-tuning is proceeding now.")

    iter <- 100
    T <- temperature

    pb <- progress_bar$new(
      total = iter,
      format = "  Finished :current/:total [:bar] :percent  remaining time :eta"
    )


    alpha.seq <- numeric(iter)
    beta.seq <- numeric(iter)
    eta.seq <- numeric(iter)
    value <- numeric(iter)

    alpha.seq[1] <- alpha
    beta.seq[1] <- beta
    eta.seq[1] <- eta

    result <- main_fun(M_val, M_tr, M_val_index, M_tr_index, A, B, group, N, alpha = alpha.seq[1], beta = beta.seq[1], eta = eta.seq[1], gamma = gamma, c = c, power = power, tol = tol)
    value[1] <- result$F_seq[order(result$F_seq, decreasing = FALSE)[1]]


    set.seed(123)
    for (j in 2:iter) {
      #T <- T*exp(-0.01*j)
      alpha.seq[j] <- rtruncnorm(n = 1, a = 0, mean = alpha.seq[j-1], sd = 1e-3)
      beta.seq[j] <- rtruncnorm(n = 1, a = 0, mean = beta.seq[j-1], sd = 1e-6)
      eta.seq[j] <- rtruncnorm(n = 1, a = 0, mean = eta.seq[j-1], sd = 1e-6)
      result <-  main_fun(M_val, M_tr, M_val_index, M_tr_index, A, B, group, N, alpha = alpha.seq[j], beta = beta.seq[j], eta = eta.seq[j],gamma = gamma, c = c, power = power, tol = tol)
      candidate <- result$F_seq[order(result$F_seq, decreasing = FALSE)[1]]
      if(candidate > value[j-1] & runif(n = 1) > exp((value[j-1]-candidate)/T)){
        value[j] <- value[j-1]
      } else {
        value[j] <- candidate
      }
      pb$tick()
    }


    opt_index <- order(value)[1]

    cat("\n", "Auto-hyperparameters-tuning is done.")
    cat("\nFinal hyper-paramaters (alpha,beta,eta) are chosen as:",c(alpha.seq[opt_index], beta.seq[opt_index], eta.seq[opt_index]))

    return(main_fun(M_val, M_tr, M_val_index, M_tr_index, A, B, group, N, alpha = alpha.seq[opt_index], beta = beta.seq[opt_index], eta = eta.seq[opt_index],gamma = gamma, c = c, power = power, tol = tol))

  }
  else{
    main_fun(M_val, M_tr, M_val_index, M_tr_index, A, B, group, N, alpha, beta, eta,gamma = gamma, c = c, power = power, tol = tol)
  }


}
